#!/usr/bin/env python3

# generates asar-dll-bindings/c/asardll.h, asardll.c, and asar/interface-lib.h,
# based on asar/interface-lib.cpp

import os
import re

src_dir = os.path.dirname(__file__)
inp_file = open(os.path.join(src_dir, "asar", "interface-lib.cpp")).read().strip()

functions = []
structs = []
patchparams_parts = []

asardll_h_funcs = []
asardll_c_protos = []
asardll_c_loads = []
interface_lib_funcs = []

apiver_start = inp_file.index("#define APIVERSION")
api_version = inp_file[apiver_start:].split("\n")[0].split()[2]

i = 0
while inp_file.find("/* $EXPORTSTRUCT_PP$", i) >= 0:
    start = inp_file.find("/* $EXPORTSTRUCT_PP$", i)
    def_start = inp_file.find("{", start)
    end = inp_file.find("\n};", def_start)
    part = "\t" + inp_file[def_start+1:end].strip()
    patchparams_parts.append(part)
    i = end
assert len(patchparams_parts) == inp_file.count("$EXPORTSTRUCT_PP$")
patchparams = "struct patchparams {\n" + "\n\n".join(patchparams_parts).rstrip() + "\n};"

i = 0
while inp_file.find("/* $EXPORTSTRUCT$", i) >= 0:
    start = inp_file.find("/* $EXPORTSTRUCT$", i)
    def_start = inp_file.find("*/", start)
    end = inp_file.find("\n};", def_start)
    part = inp_file[def_start+2:end+3]
    structs.append(part.strip())
    i = end
assert len(structs) == inp_file.count("$EXPORTSTRUCT$")
# TODO HACK: these 2 aren't from interface-lib.cpp but we still need them
structs.append("""
enum mappertype {
	invalid_mapper,
	lorom,
	hirom,
	sa1rom,
	bigsa1rom,
	sfxrom,
	exlorom,
	exhirom,
	norom
};

struct writtenblockdata {
	int pcoffset;
	int snesoffset;
	int numbytes;
};
""".strip())
structs.append(patchparams)
structs = "\n\n".join(structs)

i = 0
while inp_file.find("/* $EXPORT$", i) >= 0:
    start = inp_file.find("/* $EXPORT$", i)
    comment_start = inp_file.find("\n *", start)
    def_start = inp_file.find("*/", start)
    end = inp_file.find("{", def_start)
    signature = inp_file[def_start+2:end].strip()
    comment = '/' + inp_file[comment_start+2:def_start+2]
    functions.append(signature.strip())
    assert signature.startswith("EXPORT ")
    signature = signature[len("EXPORT "):]
    # hack because mapper_t is used extensively in asar, but mappertype is used extensively in API consumers
    signature = signature.replace("mapper_t", "mappertype")
    ret_and_name, _, params = signature.partition("(")
    params = '(' + params
    # hack because the patchparams struct is weird
    params = params.replace("patchparams_base", "patchparams")
    ret_type, _, funcname = ret_and_name.strip().rpartition(" ")
    cparams = "(void)" if params == "()" else params
    asardll_h_funcs.append(f"{comment}\nextern {ret_type} (*{funcname}){cparams};")
    asardll_c_protos.append(f"{ret_type} (*{funcname}){cparams};")
    asardll_c_loads.append(f'\tloadraw("{funcname}", {funcname});')
    interface_lib_funcs.append(f"{comment}\n{ret_type} {funcname}{cparams};")
    i = end
assert len(asardll_h_funcs) == inp_file.count("$EXPORT$")
asardll_h_funcs = "\n\n".join(asardll_h_funcs)
asardll_c_protos = "\n".join(asardll_c_protos)
asardll_c_loads = "\n".join(asardll_c_loads)
interface_lib_funcs = "\n\n".join(interface_lib_funcs)

def fmt(dir, fname, replacements):
    template = open(os.path.join(src_dir, *dir, fname+".in")).read()
    output = f"""
// note for asar devs: autogenerated by update_c_bind.py, don't edit this
// directly! either edit {fname}.in or interface-lib.cpp.
""".lstrip() + template
    for a,b in replacements.items():
        output = output.replace(a,b)
    out = open(os.path.join(src_dir, *dir, fname), 'w')
    out.write(output)
    print("wrote to",fname)

fmt(["asar-dll-bindings","c"], "asardll.h", {"$STRUCTS$": structs, "$FUNCTIONS$": asardll_h_funcs, "$APIVERSION$": api_version})
fmt(["asar"], "interface-lib.h", {"$STRUCTS$": structs, "$FUNCTIONS$": interface_lib_funcs, "$APIVERSION$": api_version})
fmt(["asar-dll-bindings","c"], "asardll.c", {"$FUNCTIONPROTOS$": asardll_c_protos, "$FUNCTIONLOADS$": asardll_c_loads})
